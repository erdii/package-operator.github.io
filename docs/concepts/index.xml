<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concepts on</title><link>https://package-operator.run/docs/concepts/</link><description>Recent content in Concepts on</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://package-operator.run/docs/concepts/index.xml" rel="self" type="application/rss+xml"/><item><title>Object Reconciliation</title><link>https://package-operator.run/docs/concepts/reconciliation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/reconciliation/</guid><description>Package Operator is watching and if needed reconciling all objects under management.
This page describes in detail how individual objects are updated.
Ordering of multiple objects is described on the Phases page. How object status is interpreted is described further on the Probes page.
Object update rules:
specified fields MUST always be reconciled to reset changes by other users additional labels and annotations for e.g. cache-control MUST be respected unspecified fields MAY be defaulted by admission controllers or webhooks unspecified fields MAY be overridden by e.</description></item><item><title>Probes</title><link>https://package-operator.run/docs/concepts/probes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/probes/</guid><description>Probes define how Package Operator judges the Availability of objects and is reporting status.
Defining Availability will depend on the specific application that is deployed.
In general, availability should reflect the health of the complete application bundle, so Package Operator can check whether it&amp;rsquo;s safe to roll over to a new revision.
Package Operator does not provide any default probes and leaves it to the author of a package to configure probing explicitly.</description></item><item><title>Object Templates</title><link>https://package-operator.run/docs/concepts/object-template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/object-template/</guid><description>ClusterObjectTemplate and ObjectTemplate are APIs defined in Package Operator. These APIs make it possible to create objects by templating a manifest and injecting values retrieved from other arbitrary source objects. The source objects are then continuously monitored and any change in the source values result in an updated templated object.
A subset of this functionality can be achieved by mounting secrets or configmaps, however there are multiple benefits to using the ObjectTemplate API.</description></item><item><title>Phases</title><link>https://package-operator.run/docs/concepts/phases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/phases/</guid><description>Phases are part of ObjectSets and ClusterObjectSets and order rollout and teardown of individual objects within a package revision to ensure repeatable and deterministic behavior.
When an ObjectSet is being reconciled, it will go through every specified phase in order. First creating or patching all objects contained within that phase and then probing them for availability.
Only when all objects within a phase are passing their availability probes, will the ObjectSet continue with the next phase, until all phases have been serviced.</description></item><item><title>Scopes</title><link>https://package-operator.run/docs/concepts/scopes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/scopes/</guid><description>The two possible values for scopes are Cluster and Namespaced.
Cluster scope allows the package to deploy cluster scoped object, such as CRDs. It also allows for deploying namespaced resources in multiple namespaces.
Namespaced scope restricts the package to only installing namespaced resources, and only into the namespace that the package is in.
Just one or both scopes can be specified for a single package.
The scopes given in the Package Manifest file determine which package resource can be used to deploy the package.</description></item><item><title>Revisions</title><link>https://package-operator.run/docs/concepts/revisions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/revisions/</guid><description>stateDiagram-v2 direction LR state &amp;quot;Revision 1&amp;quot; as rev1 state &amp;quot;Revision 2&amp;quot; as rev2 state &amp;quot;Revision 3&amp;quot; as rev3 [*] --&amp;gt; rev1 rev1 --&amp;gt; rev2 rev2 --&amp;gt; rev3 rev3 --&amp;gt; [*] Revisions are iterations and changes of a deployment over time. To support zero-downtime deployments, even if something goes wrong, Package Operator can manage multiple active revisions at the same time. This strategy is also often referred to as &amp;ldquo;A/B deployment&amp;rdquo; or &amp;ldquo;canary deployment&amp;rdquo;.</description></item><item><title>Package Format</title><link>https://package-operator.run/docs/concepts/package-format/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/package-format/</guid><description>Package Operator packages allow distributing all manifests that make up an application or operator deployment into a single artifact.
This artifact is just an empty container image containing a PackageManifest and the Kubernetes manifests in an optionally nested folder structure.
The Package or the ClusterPackage API is used to load these package container images into the cluster. This loading process will load the image contents into an ObjectDeployment.
Large Packages will automatically use the 'ObjectSlice' API to get around etcd object-size limitations.</description></item><item><title>Big Packages</title><link>https://package-operator.run/docs/concepts/big-packages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/big-packages/</guid><description>The most straightforward way of using the Package Operator APIs ObjectDeployment and ObjectSet is to define objects inline directly when creating an instance of these APIs.
etcd - the default Kubernetes database - has an object size limit of 1 MiB (etcd &amp;lt;=v3.2) or 1.5 MiB (etcd &amp;gt;v3.2).
Building packages containing multiple large objects, like CustomResourceDefinitions, or just contain a large number of objects, might run into these limits, when defining objects inline.</description></item><item><title>HyperShift Integration</title><link>https://package-operator.run/docs/concepts/hypershift-integration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/hypershift-integration/</guid><description>HyperShift is middleware for hosting OpenShift control planes at scale.
In a nutshell, HyperShift uses a central Kubernetes cluster to host the control plane components of multiple &amp;ldquo;guest&amp;rdquo; Kubernetes clusters.
HyperShift architecture refers to these clusters as &amp;ldquo;Management Cluster&amp;rdquo; and &amp;ldquo;Hosted Cluster&amp;rdquo;.
This topology gives users a new place to install applications and cluster operators. These cluster extensions don&amp;rsquo;t have to run on the Hosted Cluster, but can instead be pulled into the Management Cluster.</description></item></channel></rss>