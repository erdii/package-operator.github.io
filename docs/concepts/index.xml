<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concepts on</title><link>https://package-operator.run/docs/concepts/</link><description>Recent content in Concepts on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://package-operator.run/docs/concepts/index.xml" rel="self" type="application/rss+xml"/><item><title>Object Reconciliation</title><link>https://package-operator.run/docs/concepts/reconciliation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/reconciliation/</guid><description>Package Operator is watching and if needed reconciling all objects under management.
This page describes in detail how individual objects are updated.
Order across multiple objects is described on the Phases page.
How object status is interpreted is described further on the Probes page.
Object update rules:
specified fields MUST always be reconciled to reset changes by other users additional labels and annotations for e.g. cache-control MUST be respected unspecified fields MAY be defaulted by admission controllers or webhooks unspecified fields MAY be overridden by e.</description></item><item><title>Probes</title><link>https://package-operator.run/docs/concepts/probes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/probes/</guid><description>Probes defines how Package Operator is judging the Availability of objects and is reporting status.
Defining Availability will depend on the specific application that is deployed.
In general, availability should reflect the health of the complete application bundle, so Package Operator can check whether it&amp;rsquo;s save to roll over to a new revision.
Package Operator is not providing any default probes and leaves it to the author of a package to configure probing explicitly.</description></item><item><title>Phases</title><link>https://package-operator.run/docs/concepts/phases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/phases/</guid><description>Phases are part of ObjectSets and ClusterObjectSets and order rollout and teardown of individual objects within a package revision to ensure repeatable and deterministic behavior.
When an ObjectSet is being reconciled, it will go through every specified phase in order. First creating or patching all objects contained within that phase and then probing them for availability.
Only when all objects within a phase are passing their availability probes, will the ObjectSet continue with the next phase, until all phases have been serviced.</description></item><item><title>Revisions</title><link>https://package-operator.run/docs/concepts/revisions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/revisions/</guid><description>stateDiagram-v2 direction LR state &amp;quot;Revision 1&amp;quot; as rev1 state &amp;quot;Revision 2&amp;quot; as rev2 state &amp;quot;Revision 3&amp;quot; as rev3 [*] --&amp;gt; rev1 rev1 --&amp;gt; rev2 rev2 --&amp;gt; rev3 rev3 --&amp;gt; [*] Revisions are iterations and changes of a deployment over time. To support zero-downtime deployments, even if something goes wrong, Package Operator can manage multiple active revisions at the same time. This strategy is also often referred to as &amp;ldquo;A/B deployment&amp;rdquo; or &amp;ldquo;canary deployment&amp;rdquo;.</description></item><item><title>Package Format</title><link>https://package-operator.run/docs/concepts/package-format/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/package-format/</guid><description>Package Operator packages allow to distribute all manifests that make up an application or operator deployment into a single artifact.
This artifact is just an empty container image containing a PackageManifest and the Kubernetes manifests in an optionally nested nested folder structure.
The Package API is used to load these package container images into the cluster. This loading process will load the image contents into an ObjectDeployment.
Large Packages will automatically use the `ObjectSlice` API to get around etcd object-size limitations.</description></item><item><title>Big Packages</title><link>https://package-operator.run/docs/concepts/big-packages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://package-operator.run/docs/concepts/big-packages/</guid><description>The most straightforward way of using the Package Operator APIs ObjectDeployment and ObjectSet is to define objects inline directly when creating an instance of these APIs.
etcd - the default Kubernetes database - has an object size limit of 1 MiB (etcd &amp;lt;v3.2) or 1.5 MiB (etcd &amp;gt;v3.2).
Building packages containing multiple large objects, like CustomResourceDefinitions or are just containing a large number of objects, might run into these limits, when defining objects inline.</description></item></channel></rss>